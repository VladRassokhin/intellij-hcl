{
  "name": "vsphere",
  "type": "provider",
  "version": "v1.9.0-15-gd12abec",
  "provider": {
    "allow_unverified_ssl": {
      "Type": "Bool",
      "Optional": true,
      "Description": "If set, VMware vSphere client will permit unverifiable SSL certificates.",
      "Default": {
        "Type": "bool",
        "Value": "false"
      }
    },
    "client_debug": {
      "Type": "Bool",
      "Optional": true,
      "Description": "govmomi debug",
      "Default": {
        "Type": "bool",
        "Value": "false"
      }
    },
    "client_debug_path": {
      "Type": "String",
      "Optional": true,
      "Description": "govmomi debug path for debug",
      "Default": {
        "Type": "string"
      }
    },
    "client_debug_path_run": {
      "Type": "String",
      "Optional": true,
      "Description": "govmomi debug path for a single run",
      "Default": {
        "Type": "string"
      }
    },
    "password": {
      "Type": "String",
      "Required": true,
      "Description": "The user password for vSphere API operations."
    },
    "persist_session": {
      "Type": "Bool",
      "Optional": true,
      "Description": "Persist vSphere client sessions to disk",
      "Default": {
        "Type": "bool",
        "Value": "false"
      }
    },
    "rest_session_path": {
      "Type": "String",
      "Optional": true,
      "Description": "The directory to save vSphere REST API sessions to",
      "Default": {
        "Type": "string",
        "Value": "/home/ubuntu/.govmomi/rest_sessions"
      }
    },
    "user": {
      "Type": "String",
      "Required": true,
      "Description": "The user name for vSphere API operations."
    },
    "vcenter_server": {
      "Type": "String",
      "Optional": true,
      "Deprecated": "This field has been renamed to vsphere_server."
    },
    "vim_session_path": {
      "Type": "String",
      "Optional": true,
      "Description": "The directory to save vSphere SOAP API sessions to",
      "Default": {
        "Type": "string",
        "Value": "/home/ubuntu/.govmomi/sessions"
      }
    },
    "vsphere_server": {
      "Type": "String",
      "Optional": true,
      "Description": "The vSphere Server name for vSphere API operations."
    }
  },
  "resources": {
    "vsphere_compute_cluster": {
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datacenter_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the datacenter to put the cluster in."
      },
      "dpm_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The automation level for host power operations in this cluster. Can be one of manual or automated."
      },
      "dpm_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable DPM support for DRS. This allows you to dynamically control the power of hosts depending on the needs of virtual machines in the cluster. Requires that DRS be enabled."
      },
      "dpm_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "A value between 1 and 5 indicating the threshold of load within the cluster that influences host power operations. This affects both power on and power off operations - a lower setting will tolerate more of a surplus/deficit than a higher setting."
      },
      "drs_advanced_options": {
        "Type": "Map",
        "Optional": true,
        "Description": "Advanced configuration options for DRS and DPM."
      },
      "drs_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The default automation level for all virtual machines in this cluster. Can be one of manual, partiallyAutomated, or fullyAutomated."
      },
      "drs_enable_predictive_drs": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, enables DRS to use data from vRealize Operations Manager to make proactive DRS recommendations."
      },
      "drs_enable_vm_overrides": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, allows individual VM overrides within this cluster to be set."
      },
      "drs_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable DRS for this cluster."
      },
      "drs_migration_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "A value between 1 and 5 indicating the threshold of imbalance tolerated between hosts. A lower setting will tolerate more imbalance while a higher setting will tolerate less."
      },
      "folder": {
        "Type": "String",
        "Optional": true,
        "Description": "The name of the folder to locate the cluster in."
      },
      "force_evacuate_on_destroy": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Force removal of all hosts in the cluster during destroy and make them standalone hosts. Use of this flag mainly exists for testing and is not recommended in normal use."
      },
      "ha_admission_control_failover_host_system_ids": {
        "Type": "Set",
        "Optional": true,
        "Description": "When ha_admission_control_policy is failoverHosts, this defines the managed object IDs of hosts to use as dedicated failover hosts. These hosts are kept as available as possible - admission control will block access to the host, and DRS will ignore the host when making recommendations.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "ha_admission_control_host_failure_tolerance": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum number of failed hosts that admission control tolerates when making decisions on whether to permit virtual machine operations. The maximum is one less than the number of hosts in the cluster."
      },
      "ha_admission_control_performance_tolerance": {
        "Type": "Int",
        "Optional": true,
        "Description": "The percentage of resource reduction that a cluster of VMs can tolerate in case of a failover. A value of 0 produces warnings only, whereas a value of 100 disables the setting."
      },
      "ha_admission_control_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The type of admission control policy to use with vSphere HA, which controls whether or not specific VM operations are permitted in the cluster in order to protect the reliability of the cluster. Can be one of resourcePercentage, slotPolicy, failoverHosts, or disabled. Note that disabling admission control is not recommended and can lead to service issues."
      },
      "ha_admission_control_resource_percentage_auto_compute": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When ha_admission_control_policy is resourcePercentage, automatically determine available resource percentages by subtracting the average number of host resources represented by the ha_admission_control_host_failure_tolerance setting from the total amount of resources in the cluster. Disable to supply user-defined values."
      },
      "ha_admission_control_resource_percentage_cpu": {
        "Type": "Int",
        "Optional": true,
        "Description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of CPU resources in the cluster to reserve for failover."
      },
      "ha_admission_control_resource_percentage_memory": {
        "Type": "Int",
        "Optional": true,
        "Description": "When ha_admission_control_policy is resourcePercentage, this controls the user-defined percentage of memory resources in the cluster to reserve for failover."
      },
      "ha_admission_control_slot_policy_explicit_cpu": {
        "Type": "Int",
        "Optional": true,
        "Description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined CPU slot size, in MHz."
      },
      "ha_admission_control_slot_policy_explicit_memory": {
        "Type": "Int",
        "Optional": true,
        "Description": "When ha_admission_control_policy is slotPolicy, this controls the user-defined memory slot size, in MB."
      },
      "ha_admission_control_slot_policy_use_explicit_size": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When ha_admission_control_policy is slotPolicy, this setting controls whether or not you wish to supply explicit values to CPU and memory slot sizes. The default is to gather a automatic average based on all powered-on virtual machines currently in the cluster."
      },
      "ha_advanced_options": {
        "Type": "Map",
        "Optional": true,
        "Description": "Advanced configuration options for vSphere HA."
      },
      "ha_datastore_apd_recovery_action": {
        "Type": "String",
        "Optional": true,
        "Description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines if an APD status on an affected datastore clears in the middle of an APD event. Can be one of none or reset."
      },
      "ha_datastore_apd_response": {
        "Type": "String",
        "Optional": true,
        "Description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected loss to all paths to a relevant datastore. Can be one of disabled, warning, restartConservative, or restartAggressive."
      },
      "ha_datastore_apd_response_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "When ha_vm_component_protection is enabled, controls the delay in minutes to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response."
      },
      "ha_datastore_pdl_response": {
        "Type": "String",
        "Optional": true,
        "Description": "When ha_vm_component_protection is enabled, controls the action to take on virtual machines when the cluster has detected a permanent device loss to a relevant datastore. Can be one of disabled, warning, or restartAggressive."
      },
      "ha_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable vSphere HA for this cluster."
      },
      "ha_heartbeat_datastore_ids": {
        "Type": "Set",
        "Optional": true,
        "Description": "The list of managed object IDs for preferred datastores to use for HA heartbeating. This setting is only useful when ha_heartbeat_datastore_policy is set to either userSelectedDs or allFeasibleDsWithUserPreference.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "ha_heartbeat_datastore_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The selection policy for HA heartbeat datastores. Can be one of allFeasibleDs, userSelectedDs, or allFeasibleDsWithUserPreference."
      },
      "ha_host_isolation_response": {
        "Type": "String",
        "Optional": true,
        "Description": "The action to take on virtual machines when a host has detected that it has been isolated from the rest of the cluster. Can be one of none, powerOff, or shutdown."
      },
      "ha_host_monitoring": {
        "Type": "String",
        "Optional": true,
        "Description": "Global setting that controls whether vSphere HA remediates VMs on host failure. Can be one of enabled or disabled."
      },
      "ha_vm_component_protection": {
        "Type": "String",
        "Optional": true,
        "Description": "Controls vSphere VM component protection for virtual machines in this cluster. This allows vSphere HA to react to failures between hosts and specific virtual machine components, such as datastores. Can be one of enabled or disabled."
      },
      "ha_vm_dependency_restart_condition": {
        "Type": "String",
        "Optional": true,
        "Description": "The condition used to determine whether or not VMs in a certain restart priority class are online, allowing HA to move on to restarting VMs on the next priority. Can be one of none, poweredOn, guestHbStatusGreen, or appHbStatusGreen."
      },
      "ha_vm_failure_interval": {
        "Type": "Int",
        "Optional": true,
        "Description": "If a heartbeat from a virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds."
      },
      "ha_vm_maximum_failure_window": {
        "Type": "Int",
        "Optional": true,
        "Description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted."
      },
      "ha_vm_maximum_resets": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum number of resets that HA will perform to a virtual machine when responding to a failure event."
      },
      "ha_vm_minimum_uptime": {
        "Type": "Int",
        "Optional": true,
        "Description": "The time, in seconds, that HA waits after powering on a virtual machine before monitoring for heartbeats."
      },
      "ha_vm_monitoring": {
        "Type": "String",
        "Optional": true,
        "Description": "The type of virtual machine monitoring to use when HA is enabled in the cluster. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring."
      },
      "ha_vm_restart_additional_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "Additional delay in seconds after ready condition is met. A VM is considered ready at this point."
      },
      "ha_vm_restart_priority": {
        "Type": "String",
        "Optional": true,
        "Description": "The default restart priority for affected VMs when vSphere detects a host failure. Can be one of lowest, low, medium, high, or highest."
      },
      "ha_vm_restart_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum time, in seconds, that vSphere HA will wait for virtual machines in one priority to be ready before proceeding with the next priority."
      },
      "host_cluster_exit_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The timeout for each host maintenance mode operation when removing hosts from a cluster."
      },
      "host_system_ids": {
        "Type": "Set",
        "Optional": true,
        "Description": "The managed object IDs of the hosts to put in the cluster.",
        "MaxItems": 64,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "Name for the new cluster."
      },
      "proactive_ha_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The DRS behavior for proactive HA recommendations. Can be one of Automated or Manual."
      },
      "proactive_ha_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enables proactive HA, allowing for vSphere to get HA data from external providers and use DRS to perform remediation."
      },
      "proactive_ha_moderate_remediation": {
        "Type": "String",
        "Optional": true,
        "Description": "The configured remediation for moderately degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to MaintenanceMode when proactive_ha_severe_remediation is set to QuarantineMode."
      },
      "proactive_ha_provider_ids": {
        "Type": "Set",
        "Optional": true,
        "Description": "The list of IDs for health update providers configured for this cluster.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "proactive_ha_severe_remediation": {
        "Type": "String",
        "Optional": true,
        "Description": "The configured remediation for severely degraded hosts. Can be one of MaintenanceMode or QuarantineMode. Note that this cannot be set to QuarantineMode when proactive_ha_moderate_remediation is set to MaintenanceMode."
      },
      "resource_pool_id": {
        "Type": "String",
        "Description": "The managed object ID of the cluster's root resource pool.",
        "Computed": true
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_compute_cluster_host_group": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "host_system_ids": {
        "Type": "Set",
        "Optional": true,
        "Description": "The managed object IDs of the hosts.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      }
    },
    "vsphere_compute_cluster_vm_affinity_rule": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable this rule in the cluster."
      },
      "mandatory": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, prevents any virtual machine operations that may violate this rule."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      },
      "virtual_machine_ids": {
        "Type": "Set",
        "Required": true,
        "Description": "The UUIDs of the virtual machines to run on the same host together.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_compute_cluster_vm_anti_affinity_rule": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable this rule in the cluster."
      },
      "mandatory": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, prevents any virtual machine operations that may violate this rule."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      },
      "virtual_machine_ids": {
        "Type": "Set",
        "Required": true,
        "Description": "The UUIDs of the virtual machines to run on hosts different from each other.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_compute_cluster_vm_dependency_rule": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "dependency_vm_group_name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the VM group that this rule depends on. The VMs defined in the group specified by vm_group_name will not be started until the VMs in this group are started."
      },
      "enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable this rule in the cluster."
      },
      "mandatory": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, prevents any virtual machine operations that may violate this rule."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      },
      "vm_group_name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the VM group that is the subject of this rule. The VMs defined in this group will not be started until the VMs in the group specified by dependency_vm_group_name are started."
      }
    },
    "vsphere_compute_cluster_vm_group": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      },
      "virtual_machine_ids": {
        "Type": "Set",
        "Optional": true,
        "Description": "The UUIDs of the virtual machines in this group.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_compute_cluster_vm_host_rule": {
      "affinity_host_group_name": {
        "Type": "String",
        "Optional": true,
        "Description": "When this field is used, virtual machines defined in vm_group_name will be run on the hosts defined in this host group.",
        "ConflictsWith": [
          "anti_affinity_host_group_name"
        ]
      },
      "anti_affinity_host_group_name": {
        "Type": "String",
        "Optional": true,
        "Description": "When this field is used, virtual machines defined in vm_group_name will not be run on the hosts defined in this host group.",
        "ConflictsWith": [
          "affinity_host_group_name"
        ]
      },
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable this rule in the cluster."
      },
      "mandatory": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, prevents any virtual machine operations that may violate this rule."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      },
      "vm_group_name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the virtual machine group to use with this rule."
      }
    },
    "vsphere_custom_attribute": {
      "managed_object_type": {
        "Type": "String",
        "Optional": true,
        "Description": "Object type for which the custom attribute is valid. If not specified, the attribute is valid for all managed object types."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The display name of the custom attribute."
      }
    },
    "vsphere_datacenter": {
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "folder": {
        "Type": "String",
        "Optional": true
      },
      "moid": {
        "Type": "String",
        "Description": "Managed object ID of the datacenter.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_datastore_cluster": {
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datacenter_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the datacenter to put the datastore cluster in."
      },
      "folder": {
        "Type": "String",
        "Optional": true,
        "Description": "The name of the folder to locate the datastore cluster in."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "Name for the new storage pod."
      },
      "sdrs_advanced_options": {
        "Type": "Map",
        "Optional": true,
        "Description": "Advanced configuration options for storage DRS."
      },
      "sdrs_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The default automation level for all virtual machines in this storage cluster."
      },
      "sdrs_default_intra_vm_affinity": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, storage DRS keeps VMDKs for individual VMs on the same datastore by default."
      },
      "sdrs_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable storage DRS for this datastore cluster."
      },
      "sdrs_free_space_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "The threshold, in GB, that storage DRS uses to make decisions to migrate VMs out of a datastore."
      },
      "sdrs_free_space_threshold_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The free space threshold to use. When set to utilization, drs_space_utilization_threshold is used, and when set to freeSpace, drs_free_space_threshold is used."
      },
      "sdrs_free_space_utilization_difference": {
        "Type": "Int",
        "Optional": true,
        "Description": "The threshold, in percent, of difference between space utilization in datastores before storage DRS makes decisions to balance the space."
      },
      "sdrs_io_balance_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the default automation settings when correcting I/O load imbalances."
      },
      "sdrs_io_latency_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "The I/O latency threshold, in milliseconds, that storage DRS uses to make recommendations to move disks from this datastore."
      },
      "sdrs_io_load_balance_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable I/O load balancing for this datastore cluster."
      },
      "sdrs_io_load_imbalance_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "The difference between load in datastores in the cluster before storage DRS makes recommendations to balance the load."
      },
      "sdrs_io_reservable_iops_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "The threshold of reservable IOPS of all virtual machines on the datastore before storage DRS makes recommendations to move VMs off of a datastore."
      },
      "sdrs_io_reservable_percent_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "The threshold, in percent, of actual estimated performance of the datastore (in IOPS) that storage DRS uses to make recommendations to move VMs off of a datastore when the total reservable IOPS exceeds the threshold."
      },
      "sdrs_io_reservable_threshold_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The reservable IOPS threshold to use, percent in the event of automatic, or manual threshold in the event of manual."
      },
      "sdrs_load_balance_interval": {
        "Type": "Int",
        "Optional": true,
        "Description": "The storage DRS poll interval, in minutes."
      },
      "sdrs_policy_enforcement_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the default automation settings when correcting storage and VM policy violations."
      },
      "sdrs_rule_enforcement_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the default automation settings when correcting affinity rule violations."
      },
      "sdrs_space_balance_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the default automation settings when correcting disk space imbalances."
      },
      "sdrs_space_utilization_threshold": {
        "Type": "Int",
        "Optional": true,
        "Description": "The threshold, in percent of used space, that storage DRS uses to make decisions to migrate VMs out of a datastore."
      },
      "sdrs_vm_evacuation_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the default automation settings when generating recommendations for datastore evacuation."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_datastore_cluster_vm_anti_affinity_rule": {
      "datastore_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the datastore cluster."
      },
      "enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable this rule in the cluster."
      },
      "mandatory": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When true, prevents any virtual machine operations that may violate this rule."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The unique name of the virtual machine group in the cluster."
      },
      "virtual_machine_ids": {
        "Type": "Set",
        "Required": true,
        "Description": "The UUIDs of the virtual machines to run on different datastores from each other.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_distributed_port_group": {
      "active_uplinks": {
        "Type": "List",
        "Optional": true,
        "Description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "allow_forged_transmits": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.",
        "Computed": true
      },
      "allow_mac_changes": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the Media Access Control (MAC) address can be changed.",
        "Computed": true
      },
      "allow_promiscuous": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.",
        "Computed": true
      },
      "auto_expand": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Auto-expands the port group beyond the port count configured in number_of_ports when necessary."
      },
      "block_all_ports": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Indicates whether to block all ports by default.",
        "Computed": true
      },
      "block_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow the blocked setting of an individual port to override the setting in the portgroup."
      },
      "check_beacon": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable beacon probing on the ports this policy applies to.",
        "Computed": true
      },
      "config_version": {
        "Type": "String",
        "Description": "Version string of the configuration that this spec is trying to change.",
        "Computed": true
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "description": {
        "Type": "String",
        "Optional": true,
        "Description": "The description of the portgroup."
      },
      "directpath_gen2_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow VMDirectPath Gen2 on the ports this policy applies to.",
        "Computed": true
      },
      "distributed_virtual_switch_uuid": {
        "Type": "String",
        "Required": true,
        "Description": "The UUID of the DVS to attach this port group to."
      },
      "egress_shaping_average_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.",
        "Computed": true
      },
      "egress_shaping_burst_size": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.",
        "Computed": true
      },
      "egress_shaping_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "True if the traffic shaper is enabled for egress traffic on the port.",
        "Computed": true
      },
      "egress_shaping_peak_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.",
        "Computed": true
      },
      "failback": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.",
        "Computed": true
      },
      "ingress_shaping_average_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.",
        "Computed": true
      },
      "ingress_shaping_burst_size": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.",
        "Computed": true
      },
      "ingress_shaping_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "True if the traffic shaper is enabled for ingress traffic on the port.",
        "Computed": true
      },
      "ingress_shaping_peak_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.",
        "Computed": true
      },
      "key": {
        "Type": "String",
        "Description": "The generated UUID of the portgroup.",
        "Computed": true
      },
      "lacp_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Whether or not to enable LACP on all uplink ports.",
        "Computed": true
      },
      "lacp_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The uplink LACP mode to use. Can be one of active or passive.",
        "Computed": true
      },
      "live_port_moving_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow a live port to be moved in and out of the portgroup."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the portgroup."
      },
      "netflow_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Indicates whether to enable netflow on all ports.",
        "Computed": true
      },
      "netflow_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow the enabling or disabling of Netflow on a port, contrary to the policy in the portgroup."
      },
      "network_resource_pool_key": {
        "Type": "String",
        "Optional": true,
        "Description": "The key of a network resource pool to associate with this portgroup."
      },
      "network_resource_pool_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow the network resource pool of an individual port to override the setting in the portgroup."
      },
      "notify_switches": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.",
        "Computed": true
      },
      "number_of_ports": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of ports in this portgroup. The DVS will expand and shrink by modifying this setting.",
        "Computed": true
      },
      "port_config_reset_at_disconnect": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Reset the setting of any ports in this portgroup back to the default setting when the port disconnects."
      },
      "port_name_format": {
        "Type": "String",
        "Optional": true,
        "Description": "A template string to use when creating ports in the portgroup."
      },
      "port_private_secondary_vlan_id": {
        "Type": "Int",
        "Optional": true,
        "Description": "The secondary VLAN ID for this port.",
        "Computed": true,
        "ConflictsWith": [
          "vlan_id",
          "vlan_range"
        ]
      },
      "security_policy_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow security policy settings on a port to override those on the portgroup."
      },
      "shaping_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow the traffic shaping policies of an individual port to override the settings in the portgroup."
      },
      "standby_uplinks": {
        "Type": "List",
        "Optional": true,
        "Description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "teaming_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.",
        "Computed": true
      },
      "traffic_filter_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow any filter policies set on the individual port to override those in the portgroup."
      },
      "tx_uplink": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.",
        "Computed": true
      },
      "type": {
        "Type": "String",
        "Optional": true,
        "Description": "The type of portgroup. Can be one of earlyBinding (static) or ephemeral."
      },
      "uplink_teaming_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow the uplink teaming policies on a port to override those on the portgroup."
      },
      "vlan_id": {
        "Type": "Int",
        "Optional": true,
        "Description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.",
        "Computed": true,
        "ConflictsWith": [
          "vlan_range",
          "port_private_secondary_vlan_id"
        ]
      },
      "vlan_override_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow the VLAN configuration on a port to override those on the portgroup."
      },
      "vlan_range": {
        "Type": "Set",
        "Optional": true,
        "Description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.",
        "Computed": true,
        "ConflictsWith": [
          "vlan_id",
          "port_private_secondary_vlan_id"
        ],
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "max_vlan": {
              "Type": "Int",
              "Required": true,
              "Description": "The minimum VLAN to use in the range."
            },
            "min_vlan": {
              "Type": "Int",
              "Required": true,
              "Description": "The minimum VLAN to use in the range."
            }
          }
        }
      }
    },
    "vsphere_distributed_virtual_switch": {
      "active_uplinks": {
        "Type": "List",
        "Optional": true,
        "Description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "allow_forged_transmits": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.",
        "Computed": true
      },
      "allow_mac_changes": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the Media Access Control (MAC) address can be changed.",
        "Computed": true
      },
      "allow_promiscuous": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.",
        "Computed": true
      },
      "block_all_ports": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Indicates whether to block all ports by default.",
        "Computed": true
      },
      "check_beacon": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable beacon probing on the ports this policy applies to.",
        "Computed": true
      },
      "config_version": {
        "Type": "String",
        "Description": "The version string of the configuration that this spec is trying to change.",
        "Computed": true
      },
      "contact_detail": {
        "Type": "String",
        "Optional": true,
        "Description": "The contact detail for this DVS."
      },
      "contact_name": {
        "Type": "String",
        "Optional": true,
        "Description": "The contact name for this DVS."
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datacenter_id": {
        "Type": "String",
        "Required": true,
        "Description": "The ID of the datacenter to create this virtual switch in."
      },
      "description": {
        "Type": "String",
        "Optional": true,
        "Description": "The description of the DVS."
      },
      "directpath_gen2_allowed": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow VMDirectPath Gen2 on the ports this policy applies to.",
        "Computed": true
      },
      "egress_shaping_average_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The average egress bandwidth in bits per second if egress shaping is enabled on the port.",
        "Computed": true
      },
      "egress_shaping_burst_size": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.",
        "Computed": true
      },
      "egress_shaping_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "True if the traffic shaper is enabled for egress traffic on the port.",
        "Computed": true
      },
      "egress_shaping_peak_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.",
        "Computed": true
      },
      "failback": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.",
        "Computed": true
      },
      "faulttolerance_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.",
        "Computed": true
      },
      "faulttolerance_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.",
        "Computed": true
      },
      "faulttolerance_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the faultTolerance traffic class for a custom share level.",
        "Computed": true
      },
      "faulttolerance_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "folder": {
        "Type": "String",
        "Optional": true,
        "Description": "The folder to create this virtual switch in, relative to the datacenter."
      },
      "hbr_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the hbr traffic class, in Mbits/sec.",
        "Computed": true
      },
      "hbr_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.",
        "Computed": true
      },
      "hbr_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the hbr traffic class for a custom share level.",
        "Computed": true
      },
      "hbr_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "host": {
        "Type": "Set",
        "Optional": true,
        "Description": "A host member specification.",
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "devices": {
              "Type": "List",
              "Required": true,
              "Description": "Name of the physical NIC to be added to the proxy switch.",
              "MinItems": 1,
              "Elem": {
                "Type": "SchemaElements",
                "ElementsType": "String"
              }
            },
            "host_system_id": {
              "Type": "String",
              "Required": true,
              "Description": "The managed object ID of the host this specification applies to."
            }
          }
        }
      },
      "ingress_shaping_average_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.",
        "Computed": true
      },
      "ingress_shaping_burst_size": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.",
        "Computed": true
      },
      "ingress_shaping_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "True if the traffic shaper is enabled for ingress traffic on the port.",
        "Computed": true
      },
      "ingress_shaping_peak_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.",
        "Computed": true
      },
      "ipv4_address": {
        "Type": "String",
        "Optional": true,
        "Description": "The IPv4 address of the switch. This can be used to see the DVS as a unique device with NetFlow."
      },
      "iscsi_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.",
        "Computed": true
      },
      "iscsi_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.",
        "Computed": true
      },
      "iscsi_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the iSCSI traffic class for a custom share level.",
        "Computed": true
      },
      "iscsi_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "lacp_api_version": {
        "Type": "String",
        "Optional": true,
        "Description": "The Link Aggregation Control Protocol group version in the switch. Can be one of singleLag or multipleLag.",
        "Computed": true
      },
      "lacp_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Whether or not to enable LACP on all uplink ports.",
        "Computed": true
      },
      "lacp_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The uplink LACP mode to use. Can be one of active or passive.",
        "Computed": true
      },
      "link_discovery_operation": {
        "Type": "String",
        "Optional": true,
        "Description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none."
      },
      "link_discovery_protocol": {
        "Type": "String",
        "Optional": true,
        "Description": "The discovery protocol type. Valid values are cdp and lldp."
      },
      "management_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the management traffic class, in Mbits/sec.",
        "Computed": true
      },
      "management_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.",
        "Computed": true
      },
      "management_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the management traffic class for a custom share level.",
        "Computed": true
      },
      "management_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the management traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "max_mtu": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum MTU on the switch.",
        "Computed": true
      },
      "multicast_filtering_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The multicast filtering mode on the switch. Can be one of legacyFiltering, or snooping.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name for the DVS. Must be unique in the folder that it is being created in."
      },
      "netflow_active_flow_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of seconds after which active flows are forced to be exported to the collector."
      },
      "netflow_collector_ip_address": {
        "Type": "String",
        "Optional": true,
        "Description": "IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed Switch Version 6.0 or later."
      },
      "netflow_collector_port": {
        "Type": "Int",
        "Optional": true,
        "Description": "The port for the netflow collector."
      },
      "netflow_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Indicates whether to enable netflow on all ports.",
        "Computed": true
      },
      "netflow_idle_flow_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of seconds after which idle flows are forced to be exported to the collector."
      },
      "netflow_internal_flows_only": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Whether to limit analysis to traffic that has both source and destination served by the same host."
      },
      "netflow_observation_domain_id": {
        "Type": "Int",
        "Optional": true,
        "Description": "The observation Domain ID for the netflow collector."
      },
      "netflow_sampling_rate": {
        "Type": "Int",
        "Optional": true,
        "Description": "The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed."
      },
      "network_resource_control_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features."
      },
      "network_resource_control_version": {
        "Type": "String",
        "Optional": true,
        "Description": "The network I/O control version to use. Can be one of version2 or version3.",
        "Computed": true
      },
      "nfs_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the nfs traffic class, in Mbits/sec.",
        "Computed": true
      },
      "nfs_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.",
        "Computed": true
      },
      "nfs_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the nfs traffic class for a custom share level.",
        "Computed": true
      },
      "nfs_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "notify_switches": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.",
        "Computed": true
      },
      "port_private_secondary_vlan_id": {
        "Type": "Int",
        "Optional": true,
        "Description": "The secondary VLAN ID for this port.",
        "Computed": true,
        "ConflictsWith": [
          "vlan_id",
          "vlan_range"
        ]
      },
      "standby_uplinks": {
        "Type": "List",
        "Optional": true,
        "Description": "List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "teaming_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.",
        "Computed": true
      },
      "tx_uplink": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.",
        "Computed": true
      },
      "uplinks": {
        "Type": "List",
        "Optional": true,
        "Description": "A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "vdp_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the vdp traffic class, in Mbits/sec.",
        "Computed": true
      },
      "vdp_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.",
        "Computed": true
      },
      "vdp_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the vdp traffic class for a custom share level.",
        "Computed": true
      },
      "vdp_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "version": {
        "Type": "String",
        "Optional": true,
        "Description": "The version of this virtual switch. Allowed versions are 6.5.0, 6.0.0, 5.5.0, 5.1.0, and 5.0.0.",
        "Computed": true
      },
      "virtualmachine_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.",
        "Computed": true
      },
      "virtualmachine_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.",
        "Computed": true
      },
      "virtualmachine_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the virtualMachine traffic class for a custom share level.",
        "Computed": true
      },
      "virtualmachine_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "vlan_id": {
        "Type": "Int",
        "Optional": true,
        "Description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.",
        "Computed": true,
        "ConflictsWith": [
          "vlan_range",
          "port_private_secondary_vlan_id"
        ]
      },
      "vlan_range": {
        "Type": "Set",
        "Optional": true,
        "Description": "The VLAN ID for single VLAN mode. 0 denotes no VLAN.",
        "Computed": true,
        "ConflictsWith": [
          "vlan_id",
          "port_private_secondary_vlan_id"
        ],
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "max_vlan": {
              "Type": "Int",
              "Required": true,
              "Description": "The minimum VLAN to use in the range."
            },
            "min_vlan": {
              "Type": "Int",
              "Required": true,
              "Description": "The minimum VLAN to use in the range."
            }
          }
        }
      },
      "vmotion_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the vmotion traffic class, in Mbits/sec.",
        "Computed": true
      },
      "vmotion_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.",
        "Computed": true
      },
      "vmotion_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the vmotion traffic class for a custom share level.",
        "Computed": true
      },
      "vmotion_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      },
      "vsan_maximum_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum allowed usage for the vsan traffic class, in Mbits/sec.",
        "Computed": true
      },
      "vsan_reservation_mbit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.",
        "Computed": true
      },
      "vsan_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to the vsan traffic class for a custom share level.",
        "Computed": true
      },
      "vsan_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.",
        "Computed": true
      }
    },
    "vsphere_dpm_host_override": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "dpm_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The automation level for power operations on this host. Can be one of manual or automated."
      },
      "dpm_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable DPM for this host."
      },
      "host_system_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the host."
      }
    },
    "vsphere_drs_vm_override": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "drs_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The automation level for this virtual machine in the cluster. Can be one of manual, partiallyAutomated, or fullyAutomated."
      },
      "drs_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable DRS for this virtual machine."
      },
      "virtual_machine_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the virtual machine."
      }
    },
    "vsphere_file": {
      "create_directories": {
        "Type": "Bool",
        "Optional": true
      },
      "datacenter": {
        "Type": "String",
        "Optional": true
      },
      "datastore": {
        "Type": "String",
        "Required": true
      },
      "destination_file": {
        "Type": "String",
        "Required": true
      },
      "source_datacenter": {
        "Type": "String",
        "Optional": true
      },
      "source_datastore": {
        "Type": "String",
        "Optional": true
      },
      "source_file": {
        "Type": "String",
        "Required": true
      }
    },
    "vsphere_folder": {
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The ID of the datacenter. Can be ignored if creating a datacenter folder, otherwise required."
      },
      "path": {
        "Type": "String",
        "Required": true,
        "Description": "The path of the folder and any parents, relative to the datacenter and folder type being defined."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "type": {
        "Type": "String",
        "Required": true,
        "Description": "The type of the folder."
      }
    },
    "vsphere_ha_vm_override": {
      "compute_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the cluster."
      },
      "ha_datastore_apd_recovery_action": {
        "Type": "String",
        "Optional": true,
        "Description": "Controls the action to take on this virtual machine if an APD status on an affected datastore clears in the middle of an APD event. Can be one of useClusterDefault, none or reset."
      },
      "ha_datastore_apd_response": {
        "Type": "String",
        "Optional": true,
        "Description": "Controls the action to take on this virtual machine when the cluster has detected loss to all paths to a relevant datastore. Can be one of clusterDefault, disabled, warning, restartConservative, or restartAggressive."
      },
      "ha_datastore_apd_response_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "Controls the delay in minutes to wait after an APD timeout event to execute the response action defined in ha_datastore_apd_response. Specify -1 to use the cluster setting."
      },
      "ha_datastore_pdl_response": {
        "Type": "String",
        "Optional": true,
        "Description": "Controls the action to take on this virtual machine when the cluster has detected a permanent device loss to a relevant datastore. Can be one of clusterDefault, disabled, warning, or restartAggressive."
      },
      "ha_host_isolation_response": {
        "Type": "String",
        "Optional": true,
        "Description": "The action to take on this virtual machine when a host is isolated from the rest of the cluster. Can be one of clusterIsolationResponse, none, powerOff, or shutdown."
      },
      "ha_vm_failure_interval": {
        "Type": "Int",
        "Optional": true,
        "Description": "If a heartbeat from this virtual machine is not received within this configured interval, the virtual machine is marked as failed. The value is in seconds."
      },
      "ha_vm_maximum_failure_window": {
        "Type": "Int",
        "Optional": true,
        "Description": "The length of the reset window in which ha_vm_maximum_resets can operate. When this window expires, no more resets are attempted regardless of the setting configured in ha_vm_maximum_resets. -1 means no window, meaning an unlimited reset time is allotted."
      },
      "ha_vm_maximum_resets": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum number of resets that HA will perform to this virtual machine when responding to a failure event."
      },
      "ha_vm_minimum_uptime": {
        "Type": "Int",
        "Optional": true,
        "Description": "The time, in seconds, that HA waits after powering on this virtual machine before monitoring for heartbeats."
      },
      "ha_vm_monitoring": {
        "Type": "String",
        "Optional": true,
        "Description": "The type of virtual machine monitoring to use for this virtual machine. Can be one of vmMonitoringDisabled, vmMonitoringOnly, or vmAndAppMonitoring."
      },
      "ha_vm_monitoring_use_cluster_defaults": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Determines whether or not the cluster's default settings or the VM override settings specified in this resource are used for virtual machine monitoring. The default is true (use cluster defaults) - set to false to have overrides take effect."
      },
      "ha_vm_restart_priority": {
        "Type": "String",
        "Optional": true,
        "Description": "The restart priority for this virtual machine when vSphere detects a host failure. Can be one of clusterRestartPriority, lowest, low, medium, high, or highest."
      },
      "ha_vm_restart_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum time, in seconds, that vSphere HA will wait for the virtual machine to be ready. Use -1 to use the cluster default."
      },
      "virtual_machine_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the virtual machine."
      }
    },
    "vsphere_host_port_group": {
      "active_nics": {
        "Type": "List",
        "Optional": true,
        "Description": "List of active network adapters used for load balancing.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "allow_forged_transmits": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own."
      },
      "allow_mac_changes": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the Media Access Control (MAC) address can be changed."
      },
      "allow_promiscuous": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port."
      },
      "check_beacon": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used only."
      },
      "computed_policy": {
        "Type": "Map",
        "Description": "The effective network policy after inheritance. Note that this will look similar to, but is not the same, as the policy attributes defined in this resource.",
        "Computed": true
      },
      "failback": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up."
      },
      "host_system_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the host to set the virtual switch up on."
      },
      "key": {
        "Type": "String",
        "Description": "The linkable identifier for this port group.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the port group."
      },
      "notify_switches": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates."
      },
      "ports": {
        "Type": "Set",
        "Description": "The ports that currently exist and are used on this port group.",
        "Computed": true,
        "MaxItems": 1,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "key": {
              "Type": "String",
              "Description": "The linkable identifier for this port entry.",
              "Computed": true
            },
            "mac_addresses": {
              "Type": "List",
              "Description": "The MAC addresses of the network service of the virtual machine connected on this port.",
              "Computed": true,
              "Elem": {
                "Type": "SchemaElements",
                "ElementsType": "String"
              }
            },
            "type": {
              "Type": "String",
              "Description": "Type type of the entity connected on this port. Possible values are host (VMKkernel), systemManagement (service console), virtualMachine, or unknown.",
              "Computed": true
            }
          }
        }
      },
      "shaping_average_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The average bandwidth in bits per second if traffic shaping is enabled."
      },
      "shaping_burst_size": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum burst size allowed in bytes if traffic shaping is enabled."
      },
      "shaping_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable traffic shaping on this virtual switch or port group."
      },
      "shaping_peak_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled."
      },
      "standby_nics": {
        "Type": "List",
        "Optional": true,
        "Description": "List of standby network adapters used for failover.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "teaming_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or failover_explicit."
      },
      "virtual_switch_name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the virtual switch to bind this port group to."
      },
      "vlan_id": {
        "Type": "Int",
        "Optional": true,
        "Description": "The VLAN ID/trunk mode for this port group. An ID of 0 denotes no tagging, an ID of 1-4094 tags with the specific ID, and an ID of 4095 enables trunk mode, allowing the guest to manage its own tagging."
      }
    },
    "vsphere_host_virtual_switch": {
      "active_nics": {
        "Type": "List",
        "Required": true,
        "Description": "List of active network adapters used for load balancing.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "allow_forged_transmits": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own."
      },
      "allow_mac_changes": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the Media Access Control (MAC) address can be changed."
      },
      "allow_promiscuous": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port."
      },
      "beacon_interval": {
        "Type": "Int",
        "Optional": true,
        "Description": "Determines how often, in seconds, a beacon should be sent to probe for the validity of a link."
      },
      "check_beacon": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable beacon probing. Requires that the vSwitch has been configured to use a beacon. If disabled, link status is used only."
      },
      "failback": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up."
      },
      "host_system_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the host to set the virtual switch up on."
      },
      "link_discovery_operation": {
        "Type": "String",
        "Optional": true,
        "Description": "Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none."
      },
      "link_discovery_protocol": {
        "Type": "String",
        "Optional": true,
        "Description": "The discovery protocol type. Valid values are cdp and lldp."
      },
      "mtu": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum transmission unit (MTU) of the virtual switch in bytes."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the virtual switch."
      },
      "network_adapters": {
        "Type": "List",
        "Required": true,
        "Description": "The list of network adapters to bind to this virtual switch.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "notify_switches": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates."
      },
      "number_of_ports": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of ports that this virtual switch is configured to use."
      },
      "shaping_average_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The average bandwidth in bits per second if traffic shaping is enabled."
      },
      "shaping_burst_size": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum burst size allowed in bytes if traffic shaping is enabled."
      },
      "shaping_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable traffic shaping on this virtual switch or port group."
      },
      "shaping_peak_bandwidth": {
        "Type": "Int",
        "Optional": true,
        "Description": "The peak bandwidth during bursts in bits per second if traffic shaping is enabled."
      },
      "standby_nics": {
        "Type": "List",
        "Required": true,
        "Description": "List of standby network adapters used for failover.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "teaming_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, or failover_explicit."
      }
    },
    "vsphere_license": {
      "edition_key": {
        "Type": "String",
        "Computed": true
      },
      "labels": {
        "Type": "Map",
        "Optional": true
      },
      "license_key": {
        "Type": "String",
        "Required": true
      },
      "name": {
        "Type": "String",
        "Computed": true
      },
      "total": {
        "Type": "Int",
        "Computed": true
      },
      "used": {
        "Type": "Int",
        "Computed": true
      }
    },
    "vsphere_nas_datastore": {
      "access_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "Access mode for the mount point. Can be one of readOnly or readWrite."
      },
      "accessible": {
        "Type": "Bool",
        "Description": "The connectivity status of the datastore. If this is false, some other computed attributes may be out of date.",
        "Computed": true
      },
      "capacity": {
        "Type": "Int",
        "Description": "Maximum capacity of the datastore, in MB.",
        "Computed": true
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datastore_cluster_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datastore cluster to place the datastore in.",
        "ConflictsWith": [
          "folder"
        ]
      },
      "folder": {
        "Type": "String",
        "Optional": true,
        "Description": "The path to the datastore folder to put the datastore in.",
        "ConflictsWith": [
          "datastore_cluster_id"
        ]
      },
      "free_space": {
        "Type": "Int",
        "Description": "Available space of this datastore, in MB.",
        "Computed": true
      },
      "host_system_ids": {
        "Type": "Set",
        "Required": true,
        "Description": "The managed object IDs of the hosts to mount the datastore on.",
        "MinItems": 1,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "maintenance_mode": {
        "Type": "String",
        "Description": "The current maintenance mode state of the datastore.",
        "Computed": true
      },
      "multiple_host_access": {
        "Type": "Bool",
        "Description": "If true, more than one host in the datacenter has been configured with access to the datastore.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the datastore."
      },
      "protocol_endpoint": {
        "Type": "String",
        "Description": "Indicates that this NAS volume is a protocol endpoint. This field is only populated if the host supports virtual datastores.",
        "Computed": true
      },
      "remote_hosts": {
        "Type": "List",
        "Required": true,
        "Description": "The hostnames or IP addresses of the remote server or servers. Only one element should be present for NFS v3 but multiple can be present for NFS v4.1.",
        "MinItems": 1,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "remote_path": {
        "Type": "String",
        "Required": true,
        "Description": "The remote path of the mount point."
      },
      "security_type": {
        "Type": "String",
        "Optional": true,
        "Description": "The security type to use."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "type": {
        "Type": "String",
        "Optional": true,
        "Description": "The type of NAS volume. Can be one of NFS (to denote v3) or NFS41 (to denote NFS v4.1)."
      },
      "uncommitted_space": {
        "Type": "Int",
        "Description": "Total additional storage space, in MB, potentially used by all virtual machines on this datastore.",
        "Computed": true
      },
      "url": {
        "Type": "String",
        "Description": "The unique locator for the datastore.",
        "Computed": true
      }
    },
    "vsphere_resource_pool": {
      "cpu_expandable": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has unreserved resources."
      },
      "cpu_limit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for unlimited."
      },
      "cpu_reservation": {
        "Type": "Int",
        "Optional": true,
        "Description": "Amount of CPU (MHz) that is guaranteed available to the resource pool."
      },
      "cpu_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. Can be one of low, normal, high, or custom."
      },
      "cpu_shares": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set, cpu_share_level must be custom.",
        "Computed": true
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "memory_expandable": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Determines if the reservation on a resource pool can grow beyond the specified value, if the parent resource pool has unreserved resources."
      },
      "memory_limit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The utilization of a resource pool will not exceed this limit, even if there are available resources. Set to -1 for unlimited."
      },
      "memory_reservation": {
        "Type": "Int",
        "Optional": true,
        "Description": "Amount of memory (MB) that is guaranteed available to the resource pool."
      },
      "memory_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. Can be one of low, normal, high, or custom."
      },
      "memory_shares": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set, memory_share_level must be custom.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "Name of resource pool."
      },
      "parent_resource_pool_id": {
        "Type": "String",
        "Required": true,
        "Description": "The ID of the root resource pool of the compute resource the resource pool is in."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_storage_drs_vm_override": {
      "datastore_cluster_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the datastore cluster."
      },
      "sdrs_automation_level": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides any Storage DRS automation levels for this virtual machine."
      },
      "sdrs_enabled": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the default Storage DRS setting for this virtual machine."
      },
      "sdrs_intra_vm_affinity": {
        "Type": "String",
        "Optional": true,
        "Description": "Overrides the intra-VM affinity setting for this virtual machine."
      },
      "virtual_machine_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the virtual machine."
      }
    },
    "vsphere_tag": {
      "category_id": {
        "Type": "String",
        "Required": true,
        "Description": "The unique identifier of the parent category in which this tag will be created."
      },
      "description": {
        "Type": "String",
        "Optional": true,
        "Description": "The description of the tag."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The display name of the tag. The name must be unique within its category."
      }
    },
    "vsphere_tag_category": {
      "associable_types": {
        "Type": "Set",
        "Required": true,
        "Description": "Object types to which this category's tags can be attached.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "cardinality": {
        "Type": "String",
        "Required": true,
        "Description": "The associated cardinality of the category. Can be one of SINGLE (object can only be assigned one tag in this category) or MULTIPLE (object can be assigned multiple tags in this category)."
      },
      "description": {
        "Type": "String",
        "Optional": true,
        "Description": "The description of the category."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The display name of the category."
      }
    },
    "vsphere_vapp_container": {
      "cpu_expandable": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Determines if the reservation on a vApp container can grow beyond the specified value, if the parent resource pool has unreserved resources."
      },
      "cpu_limit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The utilization of a vApp container will not exceed this limit, even if there are available resources. Set to -1 for unlimited."
      },
      "cpu_reservation": {
        "Type": "Int",
        "Optional": true,
        "Description": "Amount of CPU (MHz) that is guaranteed available to the vApp container."
      },
      "cpu_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. Can be one of low, normal, high, or custom."
      },
      "cpu_shares": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set, cpu_share_level must be custom.",
        "Computed": true
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "memory_expandable": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Determines if the reservation on a vApp container can grow beyond the specified value, if the parent resource pool has unreserved resources."
      },
      "memory_limit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The utilization of a vApp container will not exceed this limit, even if there are available resources. Set to -1 for unlimited."
      },
      "memory_reservation": {
        "Type": "Int",
        "Optional": true,
        "Description": "Amount of memory (MB) that is guaranteed available to the vApp container."
      },
      "memory_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level. The level is a simplified view of shares. Levels map to a pre-determined set of numeric values for shares. Can be one of low, normal, high, or custom."
      },
      "memory_shares": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of shares allocated. Used to determine resource allocation in case of resource contention. If this is set, memory_share_level must be custom.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the vApp container."
      },
      "parent_folder_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The ID of the parent VM folder."
      },
      "parent_resource_pool_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the parent resource pool or the compute resource the vApp container is in."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_vapp_entity": {
      "container_id": {
        "Type": "String",
        "Required": true,
        "Description": "Managed object ID of the vApp container the entity is a member of."
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "start_action": {
        "Type": "String",
        "Optional": true,
        "Description": "How to start the entity. Valid settings are none or powerOn. If set to none, then the entity does not participate in auto-start."
      },
      "start_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "Delay in seconds before continuing with the next entity in the order of entities to be started."
      },
      "start_order": {
        "Type": "Int",
        "Optional": true,
        "Description": "Order to start and stop target in vApp."
      },
      "stop_action": {
        "Type": "String",
        "Optional": true,
        "Description": "Defines the stop action for the entity. Can be set to none, powerOff, guestShutdown, or suspend. If set to none, then the entity does not participate in auto-stop."
      },
      "stop_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "Delay in seconds before continuing with the next entity in the order of entities to be stopped."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "target_id": {
        "Type": "String",
        "Required": true,
        "Description": "Managed object ID of the entity to power on or power off. This can be a virtual machine or a vApp."
      },
      "wait_for_guest": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Determines if the VM should be marked as being started when VMware Tools are ready instead of waiting for start_delay. This property has no effect for vApps."
      }
    },
    "vsphere_virtual_disk": {
      "adapter_type": {
        "Type": "String",
        "Optional": true,
        "Deprecated": "this attribute has no effect on controller types - please use scsi_type in vsphere_virtual_machine instead"
      },
      "create_directories": {
        "Type": "Bool",
        "Optional": true
      },
      "datacenter": {
        "Type": "String",
        "Optional": true
      },
      "datastore": {
        "Type": "String",
        "Required": true
      },
      "size": {
        "Type": "Int",
        "Required": true
      },
      "type": {
        "Type": "String",
        "Optional": true
      },
      "vmdk_path": {
        "Type": "String",
        "Required": true
      }
    },
    "vsphere_virtual_machine": {
      "alternate_guest_name": {
        "Type": "String",
        "Optional": true,
        "Description": "The guest name for the operating system when guest_id is other or other-64."
      },
      "annotation": {
        "Type": "String",
        "Optional": true,
        "Description": "User-provided description of the virtual machine."
      },
      "boot_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of milliseconds to wait before starting the boot sequence."
      },
      "boot_retry_delay": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of milliseconds to wait before retrying the boot sequence. This only valid if boot_retry_enabled is true."
      },
      "boot_retry_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "If set to true, a virtual machine that fails to boot will try again after the delay defined in boot_retry_delay."
      },
      "cdrom": {
        "Type": "List",
        "Optional": true,
        "Description": "A specification for a CDROM device on this virtual machine.",
        "MaxItems": 1,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "client_device": {
              "Type": "Bool",
              "Optional": true,
              "Description": "Indicates whether the device should be mapped to a remote client device"
            },
            "datastore_id": {
              "Type": "String",
              "Optional": true,
              "Description": "The datastore ID the ISO is located on."
            },
            "device_address": {
              "Type": "String",
              "Description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.",
              "Computed": true
            },
            "key": {
              "Type": "Int",
              "Description": "The unique device ID for this device within its virtual machine.",
              "Computed": true
            },
            "path": {
              "Type": "String",
              "Optional": true,
              "Description": "The path to the ISO file on the datastore."
            }
          }
        }
      },
      "change_version": {
        "Type": "String",
        "Description": "A unique identifier for a given version of the last configuration applied, such the timestamp of the last update to the configuration.",
        "Computed": true
      },
      "clone": {
        "Type": "List",
        "Optional": true,
        "Description": "A specification for cloning a virtual machine from template.",
        "MaxItems": 1,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "customize": {
              "Type": "List",
              "Optional": true,
              "Description": "The customization spec for this clone. This allows the user to configure the virtual machine post-clone.",
              "MaxItems": 1,
              "Elem": {
                "Type": "SchemaInfo",
                "Info": {
                  "dns_server_list": {
                    "Type": "List",
                    "Optional": true,
                    "Description": "The list of DNS servers for a virtual network adapter with a static IP address.",
                    "Elem": {
                      "Type": "SchemaElements",
                      "ElementsType": "String"
                    }
                  },
                  "dns_suffix_list": {
                    "Type": "List",
                    "Optional": true,
                    "Description": "A list of DNS search domains to add to the DNS configuration on the virtual machine.",
                    "Elem": {
                      "Type": "SchemaElements",
                      "ElementsType": "String"
                    }
                  },
                  "ipv4_gateway": {
                    "Type": "String",
                    "Optional": true,
                    "Description": "The IPv4 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource."
                  },
                  "ipv6_gateway": {
                    "Type": "String",
                    "Optional": true,
                    "Description": "The IPv6 default gateway when using network_interface customization on the virtual machine. This address must be local to a static IPv4 address configured in an interface sub-resource."
                  },
                  "linux_options": {
                    "Type": "List",
                    "Optional": true,
                    "Description": "A list of configuration options specific to Linux virtual machines.",
                    "MaxItems": 1,
                    "ConflictsWith": [
                      "clone.0.customize.0.windows_options",
                      "clone.0.customize.0.windows_sysprep_text"
                    ],
                    "Elem": {
                      "Type": "SchemaInfo",
                      "Info": {
                        "domain": {
                          "Type": "String",
                          "Required": true,
                          "Description": "The FQDN for this virtual machine."
                        },
                        "host_name": {
                          "Type": "String",
                          "Required": true,
                          "Description": "The host name for this virtual machine."
                        },
                        "hw_clock_utc": {
                          "Type": "Bool",
                          "Optional": true,
                          "Description": "Specifies whether or not the hardware clock should be in UTC or not."
                        },
                        "time_zone": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "Customize the time zone on the VM. This should be a time zone-style entry, like America/Los_Angeles."
                        }
                      }
                    }
                  },
                  "network_interface": {
                    "Type": "List",
                    "Optional": true,
                    "Description": "A specification of network interface configuration options.",
                    "Elem": {
                      "Type": "SchemaInfo",
                      "Info": {
                        "dns_domain": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "A DNS search domain to add to the DNS configuration on the virtual machine."
                        },
                        "dns_server_list": {
                          "Type": "List",
                          "Optional": true,
                          "Description": "Network-interface specific DNS settings for Windows operating systems. Ignored on Linux.",
                          "Elem": {
                            "Type": "SchemaElements",
                            "ElementsType": "String"
                          }
                        },
                        "ipv4_address": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The IPv4 address assigned to this network adapter. If left blank, DHCP is used."
                        },
                        "ipv4_netmask": {
                          "Type": "Int",
                          "Optional": true,
                          "Description": "The IPv4 CIDR netmask for the supplied IP address. Ignored if DHCP is selected."
                        },
                        "ipv6_address": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The IPv6 address assigned to this network adapter. If left blank, default auto-configuration is used."
                        },
                        "ipv6_netmask": {
                          "Type": "Int",
                          "Optional": true,
                          "Description": "The IPv6 CIDR netmask for the supplied IP address. Ignored if auto-configuration is selected."
                        }
                      }
                    }
                  },
                  "timeout": {
                    "Type": "Int",
                    "Optional": true,
                    "Description": "The amount of time, in minutes, to wait for guest OS customization to complete before returning with an error. Setting this value to 0 or a negative value skips the waiter."
                  },
                  "windows_options": {
                    "Type": "List",
                    "Optional": true,
                    "Description": "A list of configuration options specific to Windows virtual machines.",
                    "MaxItems": 1,
                    "ConflictsWith": [
                      "clone.0.customize.0.linux_options",
                      "clone.0.customize.0.windows_sysprep_text"
                    ],
                    "Elem": {
                      "Type": "SchemaInfo",
                      "Info": {
                        "admin_password": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The new administrator password for this virtual machine."
                        },
                        "auto_logon": {
                          "Type": "Bool",
                          "Optional": true,
                          "Description": "Specifies whether or not the VM automatically logs on as Administrator."
                        },
                        "auto_logon_count": {
                          "Type": "Int",
                          "Optional": true,
                          "Description": "Specifies how many times the VM should auto-logon the Administrator account when auto_logon is true."
                        },
                        "computer_name": {
                          "Type": "String",
                          "Required": true,
                          "Description": "The host name for this virtual machine."
                        },
                        "domain_admin_password": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The password of the domain administrator used to join this virtual machine to the domain.",
                          "ConflictsWith": [
                            "clone.0.customize.0.windows_options.0.workgroup"
                          ]
                        },
                        "domain_admin_user": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The user account of the domain administrator used to join this virtual machine to the domain.",
                          "ConflictsWith": [
                            "clone.0.customize.0.windows_options.0.workgroup"
                          ]
                        },
                        "full_name": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The full name of the user of this virtual machine."
                        },
                        "join_domain": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The domain that the virtual machine should join.",
                          "ConflictsWith": [
                            "clone.0.customize.0.windows_options.0.workgroup"
                          ]
                        },
                        "organization_name": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The organization name this virtual machine is being installed for."
                        },
                        "product_key": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The product key for this virtual machine."
                        },
                        "run_once_command_list": {
                          "Type": "List",
                          "Optional": true,
                          "Description": "A list of commands to run at first user logon, after guest customization.",
                          "Elem": {
                            "Type": "SchemaElements",
                            "ElementsType": "String"
                          }
                        },
                        "time_zone": {
                          "Type": "Int",
                          "Optional": true,
                          "Description": "The new time zone for the virtual machine. This is a sysprep-dictated timezone code."
                        },
                        "workgroup": {
                          "Type": "String",
                          "Optional": true,
                          "Description": "The workgroup for this virtual machine if not joining a domain.",
                          "ConflictsWith": [
                            "clone.0.customize.0.windows_options.0.join_domain"
                          ]
                        }
                      }
                    }
                  },
                  "windows_sysprep_text": {
                    "Type": "String",
                    "Optional": true,
                    "Description": "Use this option to specify a windows sysprep file directly.",
                    "ConflictsWith": [
                      "clone.0.customize.0.linux_options",
                      "clone.0.customize.0.windows_options"
                    ]
                  }
                }
              }
            },
            "linked_clone": {
              "Type": "Bool",
              "Optional": true,
              "Description": "Whether or not to create a linked clone when cloning. When this option is used, the source VM must have a single snapshot associated with it."
            },
            "template_uuid": {
              "Type": "String",
              "Required": true,
              "Description": "The UUID of the source virtual machine or template."
            },
            "timeout": {
              "Type": "Int",
              "Optional": true,
              "Description": "The timeout, in minutes, to wait for the virtual machine clone to complete."
            }
          }
        }
      },
      "cpu_hot_add_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow CPUs to be added to this virtual machine while it is running."
      },
      "cpu_hot_remove_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow CPUs to be added to this virtual machine while it is running."
      },
      "cpu_limit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.%!(EXTRA string=cpu)"
      },
      "cpu_performance_counters_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable CPU performance counters on this virtual machine."
      },
      "cpu_reservation": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.%!(EXTRA string=cpu)"
      },
      "cpu_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to cpu for a custom share level.",
        "Computed": true
      },
      "cpu_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for cpu resources. Can be one of high, low, normal, or custom."
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datastore_cluster_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The ID of a datastore cluster to put the virtual machine in.",
        "ConflictsWith": [
          "datastore_id"
        ]
      },
      "datastore_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The ID of the virtual machine's datastore. The virtual machine configuration is placed here, along with any virtual disks that are created without datastores.",
        "Computed": true,
        "ConflictsWith": [
          "datastore_cluster_id"
        ]
      },
      "default_ip_address": {
        "Type": "String",
        "Description": "The IP address selected by Terraform to be used for the provisioner.",
        "Computed": true
      },
      "disk": {
        "Type": "List",
        "Optional": true,
        "Description": "A specification for a virtual disk device on this virtual machine.",
        "Computed": true,
        "MaxItems": 60,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "attach": {
              "Type": "Bool",
              "Optional": true,
              "Description": "If this is true, the disk is attached instead of created. Implies keep_on_remove.",
              "ConflictsWith": [
                "datastore_cluster_id"
              ]
            },
            "datastore_id": {
              "Type": "String",
              "Optional": true,
              "Description": "The datastore ID for this virtual disk, if different than the virtual machine.",
              "ConflictsWith": [
                "datastore_cluster_id"
              ]
            },
            "device_address": {
              "Type": "String",
              "Description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.",
              "Computed": true
            },
            "disk_mode": {
              "Type": "String",
              "Optional": true,
              "Description": "The mode of this this virtual disk for purposes of writes and snapshotting. Can be one of append, independent_nonpersistent, independent_persistent, nonpersistent, persistent, or undoable."
            },
            "disk_sharing": {
              "Type": "String",
              "Optional": true,
              "Description": "The sharing mode of this virtual disk. Can be one of sharingMultiWriter or sharingNone."
            },
            "eagerly_scrub": {
              "Type": "Bool",
              "Optional": true,
              "Description": "The virtual disk file zeroing policy when thin_provision is not true. The default is false, which lazily-zeros the disk, speeding up thick-provisioned disk creation time."
            },
            "io_limit": {
              "Type": "Int",
              "Optional": true,
              "Description": "The upper limit of IOPS that this disk can use."
            },
            "io_reservation": {
              "Type": "Int",
              "Optional": true,
              "Description": "The I/O guarantee that this disk has, in IOPS."
            },
            "io_share_count": {
              "Type": "Int",
              "Optional": true,
              "Description": "The share count for this disk when the share level is custom."
            },
            "io_share_level": {
              "Type": "String",
              "Optional": true,
              "Description": "The share allocation level for this disk. Can be one of low, normal, high, or custom."
            },
            "keep_on_remove": {
              "Type": "Bool",
              "Optional": true,
              "Description": "Set to true to keep the underlying VMDK file when removing this virtual disk from configuration."
            },
            "key": {
              "Type": "Int",
              "Description": "The unique device ID for this device within its virtual machine.",
              "Computed": true
            },
            "label": {
              "Type": "String",
              "Optional": true,
              "Description": "A unique label for this disk."
            },
            "name": {
              "Type": "String",
              "Optional": true,
              "Description": "The file name of the disk. This can be either a name or path relative to the root of the datastore. If simply a name, the disk is located with the virtual machine.",
              "Deprecated": "\nThe name attribute for virtual disks will be removed in favor of \"label\" in\nfuture releases. To transition existing disks, rename the \"name\" attribute to\n\"label\". When doing so, ensure the value of the attribute stays the same.\n\nNote that \"label\" does not control the name of a VMDK and does not need to bear\nthe name of one on new disks or virtual machines. For more information, see the\ndocumentation for the label attribute at: \n\nhttps://www.terraform.io/docs/providers/vsphere/r/virtual_machine.html#label\n"
            },
            "path": {
              "Type": "String",
              "Optional": true,
              "Description": "The full path of the virtual disk. This can only be provided if attach is set to true, otherwise it is a read-only value.",
              "Computed": true,
              "ConflictsWith": [
                "datastore_cluster_id"
              ]
            },
            "size": {
              "Type": "Int",
              "Optional": true,
              "Description": "The size of the disk, in GB."
            },
            "thin_provisioned": {
              "Type": "Bool",
              "Optional": true,
              "Description": "If true, this disk is thin provisioned, with space for the file being allocated on an as-needed basis."
            },
            "unit_number": {
              "Type": "Int",
              "Optional": true,
              "Description": "The unique device number for this disk. This number determines where on the SCSI bus this device will be attached."
            },
            "uuid": {
              "Type": "String",
              "Description": "The UUID of the virtual disk.",
              "Computed": true
            },
            "write_through": {
              "Type": "Bool",
              "Optional": true,
              "Description": "If true, writes for this disk are sent directly to the filesystem immediately instead of being buffered."
            }
          }
        }
      },
      "efi_secure_boot_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "When the boot type set in firmware is efi, this enables EFI secure boot."
      },
      "enable_disk_uuid": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Expose the UUIDs of attached virtual disks to the virtual machine, allowing access to them in the guest."
      },
      "enable_logging": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable logging on this virtual machine."
      },
      "ept_rvi_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The EPT/RVI (hardware memory virtualization) setting for this virtual machine. Can be one of automatic, on, or off."
      },
      "extra_config": {
        "Type": "Map",
        "Optional": true,
        "Description": "Extra configuration data for this virtual machine. Can be used to supply advanced parameters not normally in configuration, such as data for cloud-config (under the guestinfo namespace), or configuration data for OVF images."
      },
      "firmware": {
        "Type": "String",
        "Optional": true,
        "Description": "The firmware interface to use on the virtual machine. Can be one of bios or EFI."
      },
      "folder": {
        "Type": "String",
        "Optional": true,
        "Description": "The name of the folder to locate the virtual machine in."
      },
      "force_power_off": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Set to true to force power-off a virtual machine if a graceful guest shutdown failed for a necessary operation."
      },
      "guest_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The guest ID for the operating system."
      },
      "guest_ip_addresses": {
        "Type": "List",
        "Description": "The current list of IP addresses on this virtual machine.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "host_system_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The ID of an optional host system to pin the virtual machine to.",
        "Computed": true
      },
      "hv_mode": {
        "Type": "String",
        "Optional": true,
        "Description": "The (non-nested) hardware virtualization setting for this virtual machine. Can be one of hvAuto, hvOn, or hvOff."
      },
      "imported": {
        "Type": "Bool",
        "Description": "A flag internal to Terraform that indicates that this resource was either imported or came from a earlier major version of this resource. Reset after the first post-import or post-upgrade apply.",
        "Computed": true
      },
      "latency_sensitivity": {
        "Type": "String",
        "Optional": true,
        "Description": "Controls the scheduling delay of the virtual machine. Use a higher sensitivity for applications that require lower latency, such as VOIP, media player applications, or applications that require frequent access to mouse or keyboard devices. Can be one of low, normal, medium, or high."
      },
      "memory": {
        "Type": "Int",
        "Optional": true,
        "Description": "The size of the virtual machine's memory, in MB."
      },
      "memory_hot_add_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Allow memory to be added to this virtual machine while it is running."
      },
      "memory_limit": {
        "Type": "Int",
        "Optional": true,
        "Description": "The maximum amount of memory (in MB) or CPU (in MHz) that this virtual machine can consume, regardless of available resources.%!(EXTRA string=memory)"
      },
      "memory_reservation": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of memory (in MB) or CPU (in MHz) that this virtual machine is guaranteed.%!(EXTRA string=memory)"
      },
      "memory_share_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of shares to allocate to memory for a custom share level.",
        "Computed": true
      },
      "memory_share_level": {
        "Type": "String",
        "Optional": true,
        "Description": "The allocation level for memory resources. Can be one of high, low, normal, or custom."
      },
      "migrate_wait_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of time, in minutes, to wait for a vMotion operation to complete before failing."
      },
      "moid": {
        "Type": "String",
        "Description": "The machine object ID from VMWare",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of this virtual machine."
      },
      "nested_hv_enabled": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable nested hardware virtualization on this virtual machine, facilitating nested virtualization in the guest."
      },
      "network_interface": {
        "Type": "List",
        "Required": true,
        "Description": "A specification for a virtual NIC on this virtual machine.",
        "MaxItems": 10,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "adapter_type": {
              "Type": "String",
              "Optional": true,
              "Description": "The controller type. Can be one of e1000, e1000e, or vmxnet3."
            },
            "bandwidth_limit": {
              "Type": "Int",
              "Optional": true,
              "Description": "The upper bandwidth limit of this network interface, in Mbits/sec."
            },
            "bandwidth_reservation": {
              "Type": "Int",
              "Optional": true,
              "Description": "The bandwidth reservation of this network interface, in Mbits/sec."
            },
            "bandwidth_share_count": {
              "Type": "Int",
              "Optional": true,
              "Description": "The share count for this network interface when the share level is custom.",
              "Computed": true
            },
            "bandwidth_share_level": {
              "Type": "String",
              "Optional": true,
              "Description": "The bandwidth share allocation level for this interface. Can be one of low, normal, high, or custom."
            },
            "device_address": {
              "Type": "String",
              "Description": "The internally-computed address of this device, such as scsi:0:1, denoting scsi bus #0 and device unit 1.",
              "Computed": true
            },
            "key": {
              "Type": "Int",
              "Description": "The unique device ID for this device within its virtual machine.",
              "Computed": true
            },
            "mac_address": {
              "Type": "String",
              "Optional": true,
              "Description": "The MAC address of this network interface. Can only be manually set if use_static_mac is true.",
              "Computed": true
            },
            "network_id": {
              "Type": "String",
              "Required": true,
              "Description": "The ID of the network to connect this network interface to."
            },
            "use_static_mac": {
              "Type": "Bool",
              "Optional": true,
              "Description": "If true, the mac_address field is treated as a static MAC address and set accordingly."
            }
          }
        }
      },
      "num_cores_per_socket": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of cores to distribute amongst the CPUs in this virtual machine. If specified, the value supplied to num_cpus must be evenly divisible by this value."
      },
      "num_cpus": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of virtual processors to assign to this virtual machine."
      },
      "reboot_required": {
        "Type": "Bool",
        "Description": "Value internal to Terraform used to determine if a configuration set change requires a reboot.",
        "Computed": true
      },
      "resource_pool_id": {
        "Type": "String",
        "Required": true,
        "Description": "The ID of a resource pool to put the virtual machine in."
      },
      "run_tools_scripts_after_power_on": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable the execution of post-power-on scripts when VMware tools is installed."
      },
      "run_tools_scripts_after_resume": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable the execution of post-resume scripts when VMware tools is installed."
      },
      "run_tools_scripts_before_guest_reboot": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable the execution of pre-reboot scripts when VMware tools is installed."
      },
      "run_tools_scripts_before_guest_shutdown": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable the execution of pre-shutdown scripts when VMware tools is installed."
      },
      "run_tools_scripts_before_guest_standby": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable the execution of pre-standby scripts when VMware tools is installed."
      },
      "scsi_bus_sharing": {
        "Type": "String",
        "Optional": true,
        "Description": "Mode for sharing the SCSI bus. The modes are physicalSharing, virtualSharing, and noSharing."
      },
      "scsi_controller_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of SCSI controllers that Terraform manages on this virtual machine. This directly affects the amount of disks you can add to the virtual machine and the maximum disk unit number. Note that lowering this value does not remove controllers."
      },
      "scsi_type": {
        "Type": "String",
        "Optional": true,
        "Description": "The type of SCSI bus this virtual machine will have. Can be one of lsilogic, lsilogic-sas or pvscsi."
      },
      "shutdown_wait_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of time, in minutes, to wait for shutdown when making necessary updates to the virtual machine."
      },
      "swap_placement_policy": {
        "Type": "String",
        "Optional": true,
        "Description": "The swap file placement policy for this virtual machine. Can be one of inherit, hostLocal, or vmDirectory."
      },
      "sync_time_with_host": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Enable guest clock synchronization with the host. Requires VMware tools to be installed."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "uuid": {
        "Type": "String",
        "Description": "The UUID of the virtual machine. Also exposed as the ID of the resource.",
        "Computed": true
      },
      "vapp": {
        "Type": "List",
        "Optional": true,
        "Description": "vApp configuration data for this virtual machine. Can be used to provide configuration data for OVF images.",
        "MaxItems": 1,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "properties": {
              "Type": "Map",
              "Optional": true,
              "Description": "A map of customizable vApp properties and their values. Allows customization of VMs cloned from OVF templates which have customizable vApp properties.",
              "Elem": {
                "Type": "SchemaElements",
                "ElementsType": "String"
              }
            }
          }
        }
      },
      "vapp_transport": {
        "Type": "List",
        "Description": "vApp transport methods supported by virtual machine.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "vmware_tools_status": {
        "Type": "String",
        "Description": "The state of VMware tools in the guest. This will determine the proper course of action for some device operations.",
        "Computed": true
      },
      "vmx_path": {
        "Type": "String",
        "Description": "The path of the virtual machine's configuration file in the VM's datastore.",
        "Computed": true
      },
      "wait_for_guest_net_routable": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Controls whether or not the guest network waiter waits for a routable address. When false, the waiter does not wait for a default gateway, nor are IP addresses checked against any discovered default gateways as part of its success criteria."
      },
      "wait_for_guest_net_timeout": {
        "Type": "Int",
        "Optional": true,
        "Description": "The amount of time, in minutes, to wait for an available IP address on this virtual machine. A value less than 1 disables the waiter."
      }
    },
    "vsphere_virtual_machine_snapshot": {
      "consolidate": {
        "Type": "Bool",
        "Optional": true
      },
      "description": {
        "Type": "String",
        "Required": true
      },
      "memory": {
        "Type": "Bool",
        "Required": true
      },
      "quiesce": {
        "Type": "Bool",
        "Required": true
      },
      "remove_children": {
        "Type": "Bool",
        "Optional": true
      },
      "snapshot_name": {
        "Type": "String",
        "Required": true
      },
      "virtual_machine_uuid": {
        "Type": "String",
        "Required": true
      }
    },
    "vsphere_vmfs_datastore": {
      "accessible": {
        "Type": "Bool",
        "Description": "The connectivity status of the datastore. If this is false, some other computed attributes may be out of date.",
        "Computed": true
      },
      "capacity": {
        "Type": "Int",
        "Description": "Maximum capacity of the datastore, in MB.",
        "Computed": true
      },
      "custom_attributes": {
        "Type": "Map",
        "Optional": true,
        "Description": "A list of custom attributes to set on this resource."
      },
      "datastore_cluster_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datastore cluster to place the datastore in.",
        "ConflictsWith": [
          "folder"
        ]
      },
      "disks": {
        "Type": "List",
        "Required": true,
        "Description": "The disks to add to the datastore.",
        "MinItems": 1,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "folder": {
        "Type": "String",
        "Optional": true,
        "Description": "The path to the datastore folder to put the datastore in.",
        "ConflictsWith": [
          "datastore_cluster_id"
        ]
      },
      "free_space": {
        "Type": "Int",
        "Description": "Available space of this datastore, in MB.",
        "Computed": true
      },
      "host_system_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the host to set up the datastore on."
      },
      "maintenance_mode": {
        "Type": "String",
        "Description": "The current maintenance mode state of the datastore.",
        "Computed": true
      },
      "multiple_host_access": {
        "Type": "Bool",
        "Description": "If true, more than one host in the datacenter has been configured with access to the datastore.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the datastore."
      },
      "tags": {
        "Type": "Set",
        "Optional": true,
        "Description": "A list of tag IDs to apply to this object.",
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "uncommitted_space": {
        "Type": "Int",
        "Description": "Total additional storage space, in MB, potentially used by all virtual machines on this datastore.",
        "Computed": true
      },
      "url": {
        "Type": "String",
        "Description": "The unique locator for the datastore.",
        "Computed": true
      }
    }
  },
  "data-sources": {
    "vsphere_compute_cluster": {
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the cluster is located in. Not required if using an absolute path."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name or absolute path to the cluster."
      },
      "resource_pool_id": {
        "Type": "String",
        "Description": "The managed object ID of the cluster's root resource pool.",
        "Computed": true
      }
    },
    "vsphere_custom_attribute": {
      "managed_object_type": {
        "Type": "String",
        "Description": "Object type for which the custom attribute is valid. If not specified, the attribute is valid for all managed object types.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The display name of the custom attribute."
      }
    },
    "vsphere_datacenter": {
      "name": {
        "Type": "String",
        "Optional": true,
        "Description": "The name of the datacenter. This can be a name or path.\tCan be omitted if there is only one datacenter in your inventory."
      }
    },
    "vsphere_datastore": {
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the datastore is in. This is not required when using ESXi directly, or if there is only one datacenter in your infrastructure."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name or path of the datastore."
      }
    },
    "vsphere_datastore_cluster": {
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the cluster is located in. Not required if using an absolute path."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name or absolute path to the datastore cluster."
      }
    },
    "vsphere_distributed_virtual_switch": {
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the DVS is in. This is required if the supplied path is not an absolute path containing a datacenter and there are multiple datacenters in your infrastructure."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the distributed virtual switch. This can be a name or path."
      },
      "uplinks": {
        "Type": "List",
        "Description": "The uplink ports on this DVS.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      }
    },
    "vsphere_host": {
      "datacenter_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the datacenter to look for the host in."
      },
      "name": {
        "Type": "String",
        "Optional": true,
        "Description": "The name of the host. This can be a name or path.\tIf not provided, the default host is used."
      },
      "resource_pool_id": {
        "Type": "String",
        "Description": "The managed object ID of the host's root resource pool.",
        "Computed": true
      }
    },
    "vsphere_network": {
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the network is in. This is required if the supplied path is not an absolute path containing a datacenter and there are multiple datacenters in your infrastructure."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name or path of the network."
      },
      "type": {
        "Type": "String",
        "Description": "The managed object type of the network.",
        "Computed": true
      }
    },
    "vsphere_resource_pool": {
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the resource pool is in. This is not required when using ESXi directly, or if there is only one datacenter in your infrastructure."
      },
      "name": {
        "Type": "String",
        "Optional": true,
        "Description": "The name or path of the resource pool."
      }
    },
    "vsphere_tag": {
      "category_id": {
        "Type": "String",
        "Required": true,
        "Description": "The unique identifier of the parent category for this tag."
      },
      "description": {
        "Type": "String",
        "Description": "The description of the tag.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The display name of the tag."
      }
    },
    "vsphere_tag_category": {
      "associable_types": {
        "Type": "Set",
        "Description": "Object types to which this category's tags can be attached.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "cardinality": {
        "Type": "String",
        "Description": "The associated cardinality of the category. Can be one of SINGLE (object can only be assigned one tag in this category) or MULTIPLE (object can be assigned multiple tags in this category).",
        "Computed": true
      },
      "description": {
        "Type": "String",
        "Description": "The description of the category.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The display name of the category."
      }
    },
    "vsphere_vapp_container": {
      "datacenter_id": {
        "Type": "String",
        "Required": true,
        "Description": "The Managed Object ID of the datacenter."
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name of the vApp container."
      }
    },
    "vsphere_virtual_machine": {
      "alternate_guest_name": {
        "Type": "String",
        "Description": "The alternate guest name of the virtual machine when guest_id is a non-specific operating system, like otherGuest.",
        "Computed": true
      },
      "datacenter_id": {
        "Type": "String",
        "Optional": true,
        "Description": "The managed object ID of the datacenter the virtual machine is in. This is not required when using ESXi directly, or if there is only one datacenter in your infrastructure."
      },
      "disks": {
        "Type": "List",
        "Description": "Select configuration attributes from the disks on this virtual machine, sorted by bus and unit number.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaInfo",
          "Info": {
            "eagerly_scrub": {
              "Type": "Bool",
              "Computed": true
            },
            "size": {
              "Type": "Int",
              "Computed": true
            },
            "thin_provisioned": {
              "Type": "Bool",
              "Computed": true
            }
          }
        }
      },
      "firmware": {
        "Type": "String",
        "Description": "The firmware type for this virtual machine.",
        "Computed": true
      },
      "guest_id": {
        "Type": "String",
        "Description": "The guest ID of the virtual machine.",
        "Computed": true
      },
      "name": {
        "Type": "String",
        "Required": true,
        "Description": "The name or path of the virtual machine."
      },
      "network_interface_types": {
        "Type": "List",
        "Description": "The types of network interfaces found on the virtual machine, sorted by unit number.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "scsi_bus_sharing": {
        "Type": "String",
        "Description": "Mode for sharing the SCSI bus.",
        "Computed": true
      },
      "scsi_controller_scan_count": {
        "Type": "Int",
        "Optional": true,
        "Description": "The number of SCSI controllers to scan for disk sizes and controller types on."
      },
      "scsi_type": {
        "Type": "String",
        "Description": "The common SCSI bus type of all controllers on the virtual machine.",
        "Computed": true
      }
    },
    "vsphere_vmfs_disks": {
      "disks": {
        "Type": "List",
        "Description": "The names of the disks discovered by the search.",
        "Computed": true,
        "Elem": {
          "Type": "SchemaElements",
          "ElementsType": "String"
        }
      },
      "filter": {
        "Type": "String",
        "Optional": true,
        "Description": "A regular expression to filter the disks against. Only disks with canonical names that match will be included."
      },
      "host_system_id": {
        "Type": "String",
        "Required": true,
        "Description": "The managed object ID of the host to search for disks on."
      },
      "rescan": {
        "Type": "Bool",
        "Optional": true,
        "Description": "Rescan the system for disks before querying. This may lengthen the time it takes to gather information."
      }
    }
  }
}